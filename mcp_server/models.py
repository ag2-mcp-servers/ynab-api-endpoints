# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T12:31:13+00:00

from __future__ import annotations

from datetime import date as date_aliased
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field, RootModel, constr


class AccountType(Enum):
    checking = 'checking'
    savings = 'savings'
    cash = 'cash'
    creditCard = 'creditCard'
    lineOfCredit = 'lineOfCredit'
    otherAsset = 'otherAsset'
    otherLiability = 'otherLiability'
    mortgage = 'mortgage'
    autoLoan = 'autoLoan'
    studentLoan = 'studentLoan'
    personalLoan = 'personalLoan'
    medicalDebt = 'medicalDebt'
    otherDebt = 'otherDebt'


class Bulk(BaseModel):
    duplicate_import_ids: List[str] = Field(
        ...,
        description='If any Transactions were not created because they had an `import_id` matching a transaction already on the same account, the specified import_id(s) will be included in this list.',
    )
    transaction_ids: List[str] = Field(
        ..., description='The list of Transaction ids that were created.'
    )


class Data5(BaseModel):
    bulk: Bulk


class BulkResponse(BaseModel):
    data: Data5


class GoalTypeEnum(Enum):
    TB = 'TB'
    TBD = 'TBD'
    MF = 'MF'
    NEED = 'NEED'
    DEBT = 'DEBT'


class GoalType(RootModel[Optional[GoalTypeEnum]]):
    root: Optional[GoalTypeEnum] = Field(
        None,
        description="The type of goal, if the category has a goal (TB='Target Category Balance', TBD='Target Category Balance by Date', MF='Monthly Funding', NEED='Plan Your Spending')",
    )


class Category(BaseModel):
    activity: int = Field(..., description='Activity amount in milliunits format')
    balance: int = Field(..., description='Balance in milliunits format')
    budgeted: int = Field(..., description='Budgeted amount in milliunits format')
    category_group_id: UUID
    deleted: bool = Field(
        ...,
        description='Whether or not the category has been deleted.  Deleted categories will only be included in delta requests.',
    )
    goal_cadence: Optional[int] = Field(None, description='The goal cadence')
    goal_cadence_frequency: Optional[int] = Field(
        None, description='The goal cadence frequency'
    )
    goal_creation_month: Optional[date_aliased] = Field(
        None, description='The month a goal was created'
    )
    goal_day: Optional[int] = Field(None, description='The day of the goal')
    goal_months_to_budget: Optional[int] = Field(
        None,
        description='The number of months, including the current month, left in the current goal period.',
    )
    goal_overall_funded: Optional[int] = Field(
        None,
        description='The total amount funded towards the goal within the current goal period.',
    )
    goal_overall_left: Optional[int] = Field(
        None,
        description='The amount of funding still needed to complete the goal within the current goal period.',
    )
    goal_percentage_complete: Optional[int] = Field(
        None, description='The percentage completion of the goal'
    )
    goal_target: Optional[int] = Field(
        None, description='The goal target amount in milliunits'
    )
    goal_target_month: Optional[date_aliased] = Field(
        None,
        description='The original target month for the goal to be completed.  Only some goal types specify this date.',
    )
    goal_type: Optional[GoalType] = Field(
        None,
        description="The type of goal, if the category has a goal (TB='Target Category Balance', TBD='Target Category Balance by Date', MF='Monthly Funding', NEED='Plan Your Spending')",
    )
    goal_under_funded: Optional[int] = Field(
        None,
        description="The amount of funding still needed in the current month to stay on track towards completing the goal within the current goal period.  This amount will generally correspond to the 'Underfunded' amount in the web and mobile clients except when viewing a category with a Needed for Spending Goal in a future month.  The web and mobile clients will ignore any funding from a prior goal period when viewing category with a Needed for Spending Goal in a future month.",
    )
    hidden: bool = Field(..., description='Whether or not the category is hidden')
    id: UUID
    name: str
    note: Optional[str] = None
    original_category_group_id: Optional[UUID] = Field(
        None,
        description='If category is hidden this is the id of the category group it originally belonged to before it was hidden.',
    )


class CategoryGroup(BaseModel):
    deleted: bool = Field(
        ...,
        description='Whether or not the category group has been deleted.  Deleted category groups will only be included in delta requests.',
    )
    hidden: bool = Field(..., description='Whether or not the category group is hidden')
    id: UUID
    name: str


class CategoryGroupWithCategories(CategoryGroup):
    categories: List[Category] = Field(
        ...,
        description='Category group categories.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).',
    )


class Data7(BaseModel):
    category: Category


class CategoryResponse(BaseModel):
    data: Data7


class CurrencyFormat(BaseModel):
    currency_symbol: str
    decimal_digits: int
    decimal_separator: str
    display_symbol: bool
    example_format: str
    group_separator: str
    iso_code: str
    symbol_first: bool


class DateFormat(BaseModel):
    format: str


class ErrorDetail(BaseModel):
    detail: str
    id: str
    name: str


class ErrorResponse(BaseModel):
    error: ErrorDetail


class Type(Enum):
    transaction = 'transaction'
    subtransaction = 'subtransaction'


class LoanAccountPeriodicValue(RootModel[Optional[Dict[str, int]]]):
    root: Optional[Dict[str, int]] = None


class MonthSummary(BaseModel):
    activity: int = Field(
        ...,
        description="The total amount of transactions in the month, excluding those categorized to 'Inflow: Ready to Assign'",
    )
    age_of_money: Optional[int] = Field(
        None, description='The Age of Money as of the month'
    )
    budgeted: int = Field(..., description='The total amount budgeted in the month')
    deleted: bool = Field(
        ...,
        description='Whether or not the month has been deleted.  Deleted months will only be included in delta requests.',
    )
    income: int = Field(
        ...,
        description="The total amount of transactions categorized to 'Inflow: Ready to Assign' in the month",
    )
    month: date_aliased
    note: Optional[str] = None
    to_be_budgeted: int = Field(
        ..., description="The available amount for 'Ready to Assign'"
    )


class Payee(BaseModel):
    deleted: bool = Field(
        ...,
        description='Whether or not the payee has been deleted.  Deleted payees will only be included in delta requests.',
    )
    id: UUID
    name: str
    transfer_account_id: Optional[str] = Field(
        None,
        description='If a transfer payee, the `account_id` to which this payee transfers to',
    )


class PayeeLocation(BaseModel):
    deleted: bool = Field(
        ...,
        description='Whether or not the payee location has been deleted.  Deleted payee locations will only be included in delta requests.',
    )
    id: UUID
    latitude: str
    longitude: str
    payee_id: UUID


class Data11(BaseModel):
    payee_location: PayeeLocation


class PayeeLocationResponse(BaseModel):
    data: Data11


class Data12(BaseModel):
    payee_locations: List[PayeeLocation]


class PayeeLocationsResponse(BaseModel):
    data: Data12


class Data13(BaseModel):
    payee: Payee


class PayeeResponse(BaseModel):
    data: Data13


class Data14(BaseModel):
    payees: List[Payee]
    server_knowledge: int = Field(..., description='The knowledge of the server')


class PayeesResponse(BaseModel):
    data: Data14


class SaveAccount(BaseModel):
    balance: int = Field(
        ..., description='The current balance of the account in milliunits format'
    )
    name: str = Field(..., description='The name of the account')
    type: AccountType


class Data15(BaseModel):
    category: Category
    server_knowledge: int = Field(..., description='The knowledge of the server')


class SaveCategoryResponse(BaseModel):
    data: Data15


class SaveMonthCategory(BaseModel):
    budgeted: int = Field(..., description='Budgeted amount in milliunits format')


class SaveSubTransaction(BaseModel):
    amount: int = Field(
        ..., description='The subtransaction amount in milliunits format.'
    )
    category_id: Optional[UUID] = Field(
        None,
        description='The category for the subtransaction.  Credit Card Payment categories are not permitted and will be ignored if supplied.',
    )
    memo: Optional[constr(max_length=200)] = None
    payee_id: Optional[UUID] = Field(
        None, description='The payee for the subtransaction.'
    )
    payee_name: Optional[constr(max_length=50)] = Field(
        None,
        description='The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if import_id is also specified on parent transaction) or (2) a payee with the same name or (3) creation of a new payee.',
    )


class Cleared(Enum):
    cleared = 'cleared'
    uncleared = 'uncleared'
    reconciled = 'reconciled'


class FlagColorEnum(Enum):
    red = 'red'
    orange = 'orange'
    yellow = 'yellow'
    green = 'green'
    blue = 'blue'
    purple = 'purple'


class FlagColor(RootModel[Optional[FlagColorEnum]]):
    root: Optional[FlagColorEnum] = Field(None, description='The transaction flag')


class SaveTransactionWithOptionalFields(BaseModel):
    account_id: Optional[UUID] = None
    amount: Optional[int] = Field(
        None,
        description='The transaction amount in milliunits format.  Split transaction amounts cannot be changed and if a different amount is supplied it will be ignored.',
    )
    approved: Optional[bool] = Field(
        None,
        description='Whether or not the transaction is approved.  If not supplied, transaction will be unapproved by default.',
    )
    category_id: Optional[UUID] = Field(
        None,
        description='The category for the transaction.  To configure a split transaction, you can specify null for `category_id` and provide a `subtransactions` array as part of the transaction object.  If an existing transaction is a split, the `category_id` cannot be changed.  Credit Card Payment categories are not permitted and will be ignored if supplied.',
    )
    cleared: Optional[Cleared] = Field(
        None, description='The cleared status of the transaction'
    )
    date: Optional[date_aliased] = Field(
        None,
        description='The transaction date in ISO format (e.g. 2016-12-01).  Future dates (scheduled transactions) are not permitted.  Split transaction dates cannot be changed and if a different date is supplied it will be ignored.',
    )
    flag_color: Optional[FlagColor] = Field(None, description='The transaction flag')
    import_id: Optional[constr(max_length=36)] = Field(
        None,
        description='If specified, the new transaction will be assigned this `import_id` and considered "imported".  We will also attempt to match this imported transaction to an existing "user-entered" transation on the same account, with the same amount, and with a date +/-10 days from the imported transaction date.<br><br>Transactions imported through File Based Import or Direct Import (not through the API) are assigned an import_id in the format: \'YNAB:[milliunit_amount]:[iso_date]:[occurrence]\'. For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of \'YNAB:-294230:2015-12-30:1\'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be \'YNAB:-294230:2015-12-30:2\'.  Using a consistent format will prevent duplicates through Direct Import and File Based Import.<br><br>If import_id is omitted or specified as null, the transaction will be treated as a "user-entered" transaction. As such, it will be eligible to be matched against transactions later being imported (via DI, FBI, or API).',
    )
    memo: Optional[constr(max_length=200)] = None
    payee_id: Optional[UUID] = Field(
        None,
        description='The payee for the transaction.  To create a transfer between two accounts, use the account transfer payee pointing to the target account.  Account transfer payees are specified as `tranfer_payee_id` on the account resource.',
    )
    payee_name: Optional[constr(max_length=50)] = Field(
        None,
        description='The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if `import_id` is also specified) or (2) a payee with the same name or (3) creation of a new payee.',
    )
    subtransactions: Optional[List[SaveSubTransaction]] = Field(
        None,
        description='An array of subtransactions to configure a transaction as a split.  Updating `subtransactions` on an existing split transaction is not supported.',
    )


class ScheduledSubTransaction(BaseModel):
    amount: int = Field(
        ..., description='The scheduled subtransaction amount in milliunits format'
    )
    category_id: Optional[UUID] = None
    deleted: bool = Field(
        ...,
        description='Whether or not the scheduled subtransaction has been deleted.  Deleted scheduled subtransactions will only be included in delta requests.',
    )
    id: UUID
    memo: Optional[str] = None
    payee_id: Optional[UUID] = None
    scheduled_transaction_id: UUID
    transfer_account_id: Optional[UUID] = Field(
        None,
        description='If a transfer, the account_id which the scheduled subtransaction transfers to',
    )


class FlagColor1Enum(Enum):
    red = 'red'
    orange = 'orange'
    yellow = 'yellow'
    green = 'green'
    blue = 'blue'
    purple = 'purple'


class FlagColor1(RootModel[Optional[FlagColor1Enum]]):
    root: Optional[FlagColor1Enum] = Field(
        None, description='The scheduled transaction flag'
    )


class Frequency(Enum):
    never = 'never'
    daily = 'daily'
    weekly = 'weekly'
    everyOtherWeek = 'everyOtherWeek'
    twiceAMonth = 'twiceAMonth'
    every4Weeks = 'every4Weeks'
    monthly = 'monthly'
    everyOtherMonth = 'everyOtherMonth'
    every3Months = 'every3Months'
    every4Months = 'every4Months'
    twiceAYear = 'twiceAYear'
    yearly = 'yearly'
    everyOtherYear = 'everyOtherYear'


class ScheduledTransactionSummary(BaseModel):
    account_id: UUID
    amount: int = Field(
        ..., description='The scheduled transaction amount in milliunits format'
    )
    category_id: Optional[UUID] = None
    date_first: date_aliased = Field(
        ...,
        description='The first date for which the Scheduled Transaction was scheduled.',
    )
    date_next: date_aliased = Field(
        ...,
        description='The next date for which the Scheduled Transaction is scheduled.',
    )
    deleted: bool = Field(
        ...,
        description='Whether or not the scheduled transaction has been deleted.  Deleted scheduled transactions will only be included in delta requests.',
    )
    flag_color: Optional[FlagColor1] = Field(
        None, description='The scheduled transaction flag'
    )
    frequency: Frequency
    id: UUID
    memo: Optional[str] = None
    payee_id: Optional[UUID] = None
    transfer_account_id: Optional[UUID] = Field(
        None,
        description='If a transfer, the account_id which the scheduled transaction transfers to',
    )


class SubTransaction(BaseModel):
    amount: int = Field(
        ..., description='The subtransaction amount in milliunits format'
    )
    category_id: Optional[UUID] = None
    category_name: Optional[str] = None
    deleted: bool = Field(
        ...,
        description='Whether or not the subtransaction has been deleted.  Deleted subtransactions will only be included in delta requests.',
    )
    id: str
    memo: Optional[str] = None
    payee_id: Optional[UUID] = None
    payee_name: Optional[str] = None
    transaction_id: str
    transfer_account_id: Optional[UUID] = Field(
        None,
        description='If a transfer, the account_id which the subtransaction transfers to',
    )
    transfer_transaction_id: Optional[str] = Field(
        None,
        description='If a transfer, the id of transaction on the other side of the transfer',
    )


class DebtTransactionTypeEnum(Enum):
    payment = 'payment'
    refund = 'refund'
    fee = 'fee'
    interest = 'interest'
    escrow = 'escrow'
    balancedAdjustment = 'balancedAdjustment'
    credit = 'credit'
    charge = 'charge'


class DebtTransactionType(RootModel[Optional[DebtTransactionTypeEnum]]):
    root: Optional[DebtTransactionTypeEnum] = Field(
        None,
        description='If the transaction is a debt/loan account transaction, the type of transaction',
    )


class FlagColor2Enum(Enum):
    red = 'red'
    orange = 'orange'
    yellow = 'yellow'
    green = 'green'
    blue = 'blue'
    purple = 'purple'


class FlagColor2(RootModel[Optional[FlagColor2Enum]]):
    root: Optional[FlagColor2Enum] = Field(None, description='The transaction flag')


class TransactionSummary(BaseModel):
    account_id: UUID
    amount: int = Field(..., description='The transaction amount in milliunits format')
    approved: bool = Field(
        ..., description='Whether or not the transaction is approved'
    )
    category_id: Optional[UUID] = None
    cleared: Cleared = Field(..., description='The cleared status of the transaction')
    date: date_aliased = Field(
        ..., description='The transaction date in ISO format (e.g. 2016-12-01)'
    )
    debt_transaction_type: Optional[DebtTransactionType] = Field(
        None,
        description='If the transaction is a debt/loan account transaction, the type of transaction',
    )
    deleted: bool = Field(
        ...,
        description='Whether or not the transaction has been deleted.  Deleted transactions will only be included in delta requests.',
    )
    flag_color: Optional[FlagColor2] = Field(None, description='The transaction flag')
    id: str
    import_id: Optional[str] = Field(
        None,
        description="If the transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.",
    )
    import_payee_name: Optional[constr(max_length=200)] = Field(
        None,
        description='If the transaction was imported, the payee name that was used when importing and before applying any payee rename rules',
    )
    import_payee_name_original: Optional[constr(max_length=200)] = Field(
        None,
        description='If the transaction was imported, the original payee name as it appeared on the statement',
    )
    matched_transaction_id: Optional[str] = Field(
        None, description='If transaction is matched, the id of the matched transaction'
    )
    memo: Optional[str] = None
    payee_id: Optional[UUID] = None
    transfer_account_id: Optional[UUID] = Field(
        None, description='If a transfer transaction, the account to which it transfers'
    )
    transfer_transaction_id: Optional[str] = Field(
        None,
        description='If a transfer transaction, the id of transaction on the other side of the transfer',
    )


class Data20(BaseModel):
    transaction_ids: List[str] = Field(
        ..., description='The list of transaction ids that were imported.'
    )


class TransactionsImportResponse(BaseModel):
    data: Data20


class User(BaseModel):
    id: UUID


class Data22(BaseModel):
    user: User


class UserResponse(BaseModel):
    data: Data22


class Type1(Enum):
    uncategorized = 'uncategorized'
    unapproved = 'unapproved'


class Account(BaseModel):
    balance: int = Field(
        ..., description='The current balance of the account in milliunits format'
    )
    cleared_balance: int = Field(
        ...,
        description='The current cleared balance of the account in milliunits format',
    )
    closed: bool = Field(..., description='Whether this account is closed or not')
    debt_escrow_amounts: Optional[LoanAccountPeriodicValue] = None
    debt_interest_rates: Optional[LoanAccountPeriodicValue] = None
    debt_minimum_payments: Optional[LoanAccountPeriodicValue] = None
    debt_original_balance: Optional[int] = Field(
        None,
        description='The original debt/loan account balance, specified in milliunits format.',
    )
    deleted: bool = Field(
        ...,
        description='Whether or not the account has been deleted.  Deleted accounts will only be included in delta requests.',
    )
    direct_import_in_error: Optional[bool] = Field(
        None,
        description='If an account linked to a financial institution (direct_import_linked=true) and the linked connection is not in a healthy state, this will be true.',
    )
    direct_import_linked: Optional[bool] = Field(
        None,
        description='Whether or not the account is linked to a financial institution for automatic transaction import.',
    )
    id: UUID
    last_reconciled_at: Optional[datetime] = Field(
        None, description='A date/time specifying when the account was last reconciled.'
    )
    name: str
    note: Optional[str] = None
    on_budget: bool = Field(..., description='Whether this account is on budget or not')
    transfer_payee_id: UUID = Field(
        ...,
        description='The payee id which should be used when transferring to this account',
    )
    type: AccountType
    uncleared_balance: int = Field(
        ...,
        description='The current uncleared balance of the account in milliunits format',
    )


class Data(BaseModel):
    account: Account


class AccountResponse(BaseModel):
    data: Data


class Data1(BaseModel):
    accounts: List[Account]
    server_knowledge: int = Field(..., description='The knowledge of the server')


class AccountsResponse(BaseModel):
    data: Data1


class BudgetSettings(BaseModel):
    currency_format: CurrencyFormat
    date_format: DateFormat


class Data3(BaseModel):
    settings: BudgetSettings


class BudgetSettingsResponse(BaseModel):
    data: Data3


class BudgetSummary(BaseModel):
    accounts: Optional[List[Account]] = Field(
        None,
        description='The budget accounts (only included if `include_accounts=true` specified as query parameter)',
    )
    currency_format: Optional[CurrencyFormat] = None
    date_format: Optional[DateFormat] = None
    first_month: Optional[date_aliased] = Field(
        None, description='The earliest budget month'
    )
    id: UUID
    last_modified_on: Optional[datetime] = Field(
        None,
        description='The last time any changes were made to the budget from either a web or mobile client',
    )
    last_month: Optional[date_aliased] = Field(
        None, description='The latest budget month'
    )
    name: str


class Data4(BaseModel):
    budgets: List[BudgetSummary]
    default_budget: Optional[BudgetSummary] = None


class BudgetSummaryResponse(BaseModel):
    data: Data4


class Data6(BaseModel):
    category_groups: List[CategoryGroupWithCategories]
    server_knowledge: int = Field(..., description='The knowledge of the server')


class CategoriesResponse(BaseModel):
    data: Data6


class HybridTransaction(TransactionSummary):
    account_name: str
    category_name: Optional[str] = None
    parent_transaction_id: Optional[str] = Field(
        None,
        description='For subtransaction types, this is the id of the parent transaction.  For transaction types, this id will be always be null.',
    )
    payee_name: Optional[str] = None
    type: Type = Field(
        ...,
        description='Whether the hybrid transaction represents a regular transaction or a subtransaction',
    )


class Data8(BaseModel):
    server_knowledge: Optional[int] = Field(
        None, description='The knowledge of the server'
    )
    transactions: List[HybridTransaction]


class HybridTransactionsResponse(BaseModel):
    data: Data8


class MonthDetail(MonthSummary):
    categories: List[Category] = Field(
        ...,
        description='The budget month categories.  Amounts (budgeted, activity, balance, etc.) are specific to the {month} parameter specified.',
    )


class Data9(BaseModel):
    month: MonthDetail


class MonthDetailResponse(BaseModel):
    data: Data9


class Data10(BaseModel):
    months: List[MonthSummary]
    server_knowledge: int = Field(..., description='The knowledge of the server')


class MonthSummariesResponse(BaseModel):
    data: Data10


class PatchMonthCategoryWrapper(BaseModel):
    category: SaveMonthCategory


class PostAccountWrapper(BaseModel):
    account: SaveAccount


SaveTransaction = SaveTransactionWithOptionalFields


class SaveTransactionWithId(SaveTransactionWithOptionalFields):
    id: Optional[str] = None


class ScheduledTransactionDetail(ScheduledTransactionSummary):
    account_name: str
    category_name: Optional[str] = None
    payee_name: Optional[str] = None
    subtransactions: List[ScheduledSubTransaction] = Field(
        ..., description='If a split scheduled transaction, the subtransactions.'
    )


class Data17(BaseModel):
    scheduled_transaction: ScheduledTransactionDetail


class ScheduledTransactionResponse(BaseModel):
    data: Data17


class Data18(BaseModel):
    scheduled_transactions: List[ScheduledTransactionDetail]
    server_knowledge: int = Field(..., description='The knowledge of the server')


class ScheduledTransactionsResponse(BaseModel):
    data: Data18


class TransactionDetail(TransactionSummary):
    account_name: str
    category_name: Optional[str] = None
    payee_name: Optional[str] = None
    subtransactions: List[SubTransaction] = Field(
        ..., description='If a split transaction, the subtransactions.'
    )


class Data19(BaseModel):
    transaction: TransactionDetail


class TransactionResponse(BaseModel):
    data: Data19


class Data21(BaseModel):
    server_knowledge: int = Field(..., description='The knowledge of the server')
    transactions: List[TransactionDetail]


class TransactionsResponse(BaseModel):
    data: Data21


class BudgetDetail(BudgetSummary):
    accounts: Optional[List[Account]] = None
    categories: Optional[List[Category]] = None
    category_groups: Optional[List[CategoryGroup]] = None
    months: Optional[List[MonthDetail]] = None
    payee_locations: Optional[List[PayeeLocation]] = None
    payees: Optional[List[Payee]] = None
    scheduled_subtransactions: Optional[List[ScheduledSubTransaction]] = None
    scheduled_transactions: Optional[List[ScheduledTransactionSummary]] = None
    subtransactions: Optional[List[SubTransaction]] = None
    transactions: Optional[List[TransactionSummary]] = None


class Data2(BaseModel):
    budget: BudgetDetail
    server_knowledge: int = Field(..., description='The knowledge of the server')


class BudgetDetailResponse(BaseModel):
    data: Data2


class BulkTransactions(BaseModel):
    transactions: List[SaveTransaction]


class PatchTransactionsWrapper(BaseModel):
    transactions: List[SaveTransactionWithId]


class PostTransactionsWrapper(BaseModel):
    transaction: Optional[SaveTransaction] = None
    transactions: Optional[List[SaveTransaction]] = None


class PutTransactionWrapper(BaseModel):
    transaction: SaveTransaction


class Data16(BaseModel):
    duplicate_import_ids: Optional[List[str]] = Field(
        None,
        description='If multiple transactions were specified, a list of import_ids that were not created because of an existing `import_id` found on the same account',
    )
    server_knowledge: int = Field(..., description='The knowledge of the server')
    transaction: Optional[TransactionDetail] = None
    transaction_ids: List[str] = Field(
        ..., description='The transaction ids that were saved'
    )
    transactions: Optional[List[TransactionDetail]] = Field(
        None,
        description='If multiple transactions were specified, the transactions that were saved',
    )


class SaveTransactionsResponse(BaseModel):
    data: Data16
